# -*- mode: python;-*-

from typing import Tuple, NamedTuple, List, Dict, Union, Type, Any, Optional
import secrets
import zipfile
import string
import logging
from pathlib import Path
import distutils.dir_util


from ..message.header import (
    Uri, Topic, QueueName, FilePath,
    Asset, S3Asset, UriAsset, AssetSettings, Decompression)

from ..outcome import Outcome, Success, Failure
from ..utils.iteratorextras import flatten, nth
from .s3path import S3Path


def localizeAssets(assets:Asset[]) -> Outcome:
    """Localize (ie., download to local node and write to disk) a List of
       Asset's according to the rules for each Asset type.
       Cleans up and returns Failure if localization fails for *any* Asset.
       Returns a list of local targets inside a Success if everything succeeded.
    """
    outcomes = concurrent_map(localizeAsset, assets) |> list
    hasFailures = False
    for oc, nm in zip(outcomes, map(str, assets)):
        if isinstance(oc, Failure):
            logging.fatal("Fatal error localizing {}: {}".format(nm, oc.reason))
            hasFailures = True

    if hasFailures:
        # Cleanup
        for outcome in outcomes:
            if isinstance(outcome, Success):
                Path(outcome.value).unlink()
        return Failure("Unable to localize one or more assets")
    else:
        return Success(map(.value, outcomes) |> list)


def localizeAsset(asset:Asset) -> Outcome:
    """Localize a single Asset
    """
    tempname = genUniqueAssetName(asset)

    return ( localizeAssetTyped(asset, tempname) >>
             decompressIfRequired$(?, asset) >>
             renameToLocalTarget$(?, asset) )

# These localizeAssetTyped patterns *must* return Success(target) if all
# went well. (That allows easier composition and chaining.) We start with
# a fake method so we can selectively attach new @addpattern versions to it
# based on available imports.
def localizeAssetTyped(None):
    pass

# Boto is large, so don't assume s3 utils are available:
try:
    from . import s3utils
    @addpattern(localizeAssetTyped) # type: ignore
    def localizeAssetTyped(S3Asset(path, _), target):
        # type: (Asset, str) -> Outcome
        """Localize an Asset stored in S3; assumes AWS credentials exist in the
        environment
        """
        return s3utils.downloadFile(path, target)
except ImportError:
    pass # Won't be able to handle S3Assets


try:
    import requests
    @addpattern(localizeAssetTyped) # type: ignore
    def localizeAssetTyped(UriAsset(uri, _), target):
        # type: (UriAsset, str) -> Outcome
        """Localize a standard URI Asset
        """
        # TODO: do some stuff with requests.py
        return Success(target)
except ModuleNotFoundError:
    pass


def genUniqueAssetName(asset:Asset) -> str:
    """Generate unique name for asset while keeping the asset's extension intact
    """
    return "{}.{}".format(randomName(), getAssetRawExt(asset))


def randomName() -> str:
    """Generate a filesystem-appropriate name with low chance of collision
    """
    return secrets.token_hex(8)


def decompressIfRequired(fname:str, asset:Asset) -> Outcome:
    """Invokes decompression if asset has been marked for decompression;
       successful Outcome will contain the filename that should be used
       for processing beyond this point
    """
    if asset.settings.decompression.decompress:
        return decompress(fname)
    else:
        return Success(fname)


def decompress(path:str) -> Outcome:
    """Chooses and invokes a decompressor based on file extension of path
    """
    pth = Path(path)
    case pth.suffix:
        match ".zip":
            return decompressZip(path)
        match ".gz":
            return decompressGzip(path)

    return Failure("Unable to determine decompressor from file extension")


def decompressZip(file:str) -> Outcome:
    """Decompress ZipFile `file` into a unique dir
    """
    tmpdir = randomName()
    try:
        with zipfile.ZipFile(file) as z:
            z.extractall(path=tmpdir)
        Path(file).unlink() # Don't leave the uncompressed archive sitting around
        return Success(tmpdir)
    except Exception as err:
        if Path(tmpdir).exists(): # Clean up if things go wrong
            distutils.dir_util.remove_tree(tmpdir)
            Path(file).unlink()
        return Failure("Decompression error: {}".format(err))


def decompressGzip(file:str) -> Outcome:
    """Decompress a .gz or .tgz file.
       ONLY decompresses; does NOT explode .tar.gz or .tgz!
    """
    # TODO: Decompress and then return the decompressed file's name
    raise NotImplementedError
    return Success(file)


def renameToLocalTarget(fname:str, asset:Asset) -> Outcome:
    """Rename an Asset to the requested localTarget
    """
    target = decideLocalTarget(asset)
    targetPath = Path(target)
    try:
        targetPath.parent.mkdir(parents=True, exist_ok=True)
        if targetPath.name is not ".":
            Path(fname).rename(targetPath)
        else:
            # FIXME: I don't like this. Python does not have a good library function
            # to recursively move files. Should write my own to avoid unnecessary disk
            # use in this copy all then delete all process.
            if Path(fname).is_dir():
                distutils.dir_util.copy_tree(fname, target)
                distutils.dir_util.remove_tree(fname)
            else:
                return Failure("Unable to rename a file to {}".format(targetPath))
        return Success(target)
    except Exception as err:
        return Failure("Error renaming to local target {}: {}".format(target, err))


def getAssetRawExt(asset:Asset) -> str:
    """Returns complete file extension on the *raw* identifier contained in
       Asset; eg., https://my.domain.com/a_file.json.gz  ->  json.gz
    """
    leaf = decideLocalTargetTyped(asset)
    ext = leaf |> .split('.') |> .[1:] |> '.'.join
    return ext


def decideLocalTarget(asset:Asset) -> str:
    if asset.settings.localTarget:
        return asset.settings.localTarget
    else:
        return decideLocalTargetTyped(asset)


def decideLocalTargetTyped(S3Asset(path, _)):
    # type: (Asset) -> str
    """Remove protocol and bucket from path, returning *full* S3 key
    """
    target = path |> .split('/') |> .[3:] |> '/'.join
    return target


@addpattern(decideLocalTargetTyped) # type: ignore
def decideLocalTargetTyped(UriAsset(uri, _)):
    """Return everything in uri past the last '/'
    """
    target = uri |> .split('/') |> .[-1]
    return target
