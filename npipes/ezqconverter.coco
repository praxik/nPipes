# -*- mode: python;-*-

from typing import Tuple, Type, NewType
import yaml
import pathlib
import secrets
import platform
from contextlib import contextmanager

from .header import (Header, Step, Trigger, TriggerGet, Uri, QueueName, TriggerSqs,
                     ProtocolEZQ, Command, FilePath, OutputChannelFile,
                     S3Asset, Decompression, AssetSettings)

from .body import (BodyInString, BodyInAsset)
from .utils.autodeleter import autoDeleteFile
from .assets import randomName


# Using injection of cls = Message to break dep cycle. Downside is this
# hides the Message and Body types, so we're not getting full benefit of
# typechecking in this module.
@contextmanager
def convertFromEZQ(cls, s):
    ezqHeader, bodyStr = fromString(s)
    # Only handleing S3 assets, since that is all we've ever used with EZQ
    assets = makeAssets(ezqHeader)
    body, assets = makeBody(bodyStr, ezqHeader, assets)
    # For OutputChannel, EZQ assumed a file named "output_#{@id}.txt",
    # where @id is the sqs :message_id
    # Apps set to run under ezq mostly take a -o cmdline arg and expect
    # the variable $id to be expanded into whatever is needed. So here we
    # choose an id, expand $id in the cmdStr, then set outfile to output_$id.txt
    id = secrets.token_hex(4)
    outfile = FilePath("output_{}.txt".format(id))
    fullMsgFilename = randomName() + ".ezq_full_msg"
    arglist = ( makeArglist(id, ezqHeader)
                |> substituteNpipesMarkers$(fullMsgFilename) )
    command = Command( arglist=arglist,
                       outputChannel=OutputChannelFile(outfile))
    steps = makeSteps(id, command, assets, ezqHeader)

    with autoDeleteFile(fullMsgFilename) as fmf:
        writeEZQFullMessage(fmf, ezqHeader, bodyStr)
        yield cls(Header(steps=steps), body=body)


def writeEZQFullMessage(filename, preamble, body):
    with open(filename, "w+") as file:
        {"body": body, "preamble": preamble} |> yaml.safe_dump |> file.write

def makeSteps(id, command, assets, ezqHeader):
    firstStep = Step( id="0",
                      command=command,
                      assets=assets )
    result_queue_name = ezqHeader.get("result_queue_name", False)
    if result_queue_name:
        # EZQ has no concept of future Steps; only the Trigger matters
        secondStep = Step( id="1",
                           trigger=TriggerSqs(QueueName(result_queue_name)))
        return [firstStep, secondStep]
    else:
        return [firstStep]


def fromString(s):
    ezqHeaderStr, bodyStr = s.split("\n...\n")
    ezqHeader = yaml.safe_load(ezqHeaderStr)["EZQ"]
    return [ezqHeader, bodyStr]


def makeArglist(id, ezqHeader):
    arglist = [""]
    cmdStr = ezqHeader.get("process_command", False)
    if cmdStr:
        # EZQ handles commands as strings, and assumes a shell for invocation,
        # so duplicate that here.
        ncs = cmdStr.replace("$id", id)
        if platform.system() == "Windows":
            # Windows always invokes a shell, and always converts a proper arglist
            # to a command string anyway
            arglist = [ncs]
        else:
            arglist = ["bash", "-c", ncs]
    return arglist


def substituteNpipesMarkers(fullMsgFilename, arglist):
    subbed = []
    for elem in arglist:
        newelem = ( elem.replace("$msg_contents", "${escapedbodycontents}")
                        .replace("$timeout", "${timeout}")
                        .replace("$input_file", "${bodyfile}")
                        .replace("$full_msg_file", fullMsgFilename)
                  )
        for x in range(10):
            newelem = newelem.replace("$s3_{}".format(x), "${{asset_{}}}".format(x))
        subbed.append(newelem)
    return subbed
# For the tests to be written later:
# substituteNpipesMarkers(["bash", "-c", "command $s3_1 $s3_2 static $s3_4 $s3_3"])
# ['bash', '-c', 'command ${asset_1} ${asset_2} static ${asset_4} ${asset_3}']

def makeBody(bodyStr, ezqHeader, assets):
    if ezqHeader.get("get_s3_file_as_body", False):
        bodyAssetIndex = len(assets)
        bodyAsset = [s3DictToAsset(ezqHeader["get_s3_file_as_body"], bodyAssetIndex)]
        assets.append(bodyAsset)
        body = BodyInAsset(assetId=str(bodyAssetIndex))
    else:
        body = BodyInString(string=bodyStr)
        bodyAsset = []
    return [body, assets + bodyAsset]


def makeAssets(ezqHeader):
    assets: List[Asset] = []
    # aindex is a monotonically increasing number to use as an ID
    for aindex, item in enumerate(ezqHeader.get("get_s3_files", [])):
        assets.append(s3DictToAsset(item, aindex))
    return assets


def s3DictToAsset(d, idint):
    key = d["key"]
    path = "s3://{bucket}/{key}".format( bucket=d["bucket"],
                                            key=key)
    decompress = d.get("decompress", False)
    # EZQ specifies that .gz files *always* be decompressed,
    # regardless of decompression flag
    if pathlib.Path(key).suffix == ".gz":
        decompress = True

    dc = Decompression(decompress)
    settings = AssetSettings( id="asset_{}".format(idint),
                              decompression=dc)
    return S3Asset( path=path, settings=settings )
