# -*- mode: python;-*-

from typing import Tuple, Type, NewType
import json
import yaml
import pathlib
import secrets

from .serialize import Serializable, toJson
from .header import (Header, Step, Trigger, TriggerGet, Uri, QueueName, TriggerSqs,
                     ProtocolEZQ, Command, FilePath, OutputChannelFile,
                     S3Asset, Decompression, AssetSettings, NestedStepListType)
from .ezqconverter import convertFromEZQ

##############################################################################
# Typealiases
##############################################################################

Body = NewType("Body", str)


########################
# Message
########################
data Message( header:Header=Header(),
              body:Body=Body("") ) from Serializable:
    def _toDict(self) = { "header": self.header._toDict(),
                          "body": self.body
		        }
    def _fromDict(d) = Message( body=d.get("body"),
                                header=Header._fromDict(d.get("header")))

    # TODO: probably want an optimization option that creates a Header
    # object with a single Step, one of each Asset type, etc., then walks the
    # emitted dict for the fake Header and the real Header and removes all parts
    # of the real Header that are equal to the fake one. That should allow for
    # complicated Headers with lots of steps to be compacted greatly. Other
    # option, I suppose, would be to gzip then base64encode the header line.
    def toJsonLines(self) = "{header}\n{body}".
                                format(header=toJson(self.header),
                                       body=self.body)

    def fromJsonLines(s):
        # Header is a single JSON line; Body is remainder of string
        h, *t = s.splitlines()
        header = json.loads(h)
        body = "\n".join(t)
        return Message._fromDict({"header": header, "body": body})

    def fromStr(s):
        if s.startswith("---\nEZQ"):
            return convertFromEZQ(Message, s)
        else:
            return Message.fromJsonLines(s)



##############################################################################
# Functions
##############################################################################

def peekStep(Header(steps), n=0):
    # type: (Header, int) -> Step
    """Returns the nth Step in header"""
    return steps[n]

@addpattern(peekStep) # type: ignore
def peekStep(Message(header, _), n=0):
    # type: (Message, int) -> Step
    """Returns the nth Step in message"""
    return peekStep(header, n)


def popStep(header:Header) -> Tuple[Step, Header]:
    """Returns first Step in header, along with a new Header
       containing the remaining Step's"""
    step = header.steps[0]
    nh = Header(header.steps[1:])
    return (step, nh)


def peekTrigger(Header(steps), n=0):
    # type: (Header, int) -> Trigger
    """Returns the Trigger for the nth Step in header"""
    return steps[n].trigger

@addpattern(peekTrigger) # type: ignore
def peekTrigger(Message(header, _), n=0):
    # type: (Message, int) -> Trigger
    """Returns the Trigger for the nth Step in message"""
    return peekTrigger(header, n)
